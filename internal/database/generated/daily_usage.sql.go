// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: daily_usage.sql

package queries

import (
	"context"
	"database/sql"
	"time"
)

const createDailyUsage = `-- name: CreateDailyUsage :one

INSERT INTO daily_usage (date, total_time)
VALUES (?, ?)
RETURNING id, date, total_time, created_at, updated_at
`

type CreateDailyUsageParams struct {
	Date      time.Time `db:"date" json:"date"`
	TotalTime int64     `db:"total_time" json:"total_time"`
}

// Daily Usage Queries
// These queries handle CRUD operations for daily usage summaries
func (q *Queries) CreateDailyUsage(ctx context.Context, arg CreateDailyUsageParams) (DailyUsage, error) {
	row := q.queryRow(ctx, q.createDailyUsageStmt, createDailyUsage, arg.Date, arg.TotalTime)
	var i DailyUsage
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.TotalTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteDailyUsage = `-- name: DeleteDailyUsage :exec
DELETE FROM daily_usage
WHERE date = ?
`

func (q *Queries) DeleteDailyUsage(ctx context.Context, date time.Time) error {
	_, err := q.exec(ctx, q.deleteDailyUsageStmt, deleteDailyUsage, date)
	return err
}

const deleteOldDailyUsage = `-- name: DeleteOldDailyUsage :exec
DELETE FROM daily_usage
WHERE date < ?
`

func (q *Queries) DeleteOldDailyUsage(ctx context.Context, date time.Time) error {
	_, err := q.exec(ctx, q.deleteOldDailyUsageStmt, deleteOldDailyUsage, date)
	return err
}

const getAllDailyUsage = `-- name: GetAllDailyUsage :many
SELECT id, date, total_time, created_at, updated_at FROM daily_usage
ORDER BY date DESC
`

func (q *Queries) GetAllDailyUsage(ctx context.Context) ([]DailyUsage, error) {
	rows, err := q.query(ctx, q.getAllDailyUsageStmt, getAllDailyUsage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DailyUsage
	for rows.Next() {
		var i DailyUsage
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.TotalTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDailyUsageByDate = `-- name: GetDailyUsageByDate :one
SELECT id, date, total_time, created_at, updated_at FROM daily_usage
WHERE date = ?
`

func (q *Queries) GetDailyUsageByDate(ctx context.Context, date time.Time) (DailyUsage, error) {
	row := q.queryRow(ctx, q.getDailyUsageByDateStmt, getDailyUsageByDate, date)
	var i DailyUsage
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.TotalTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDailyUsageByDateRange = `-- name: GetDailyUsageByDateRange :many
SELECT id, date, total_time, created_at, updated_at FROM daily_usage
WHERE date >= ? AND date <= ?
ORDER BY date ASC
`

type GetDailyUsageByDateRangeParams struct {
	Date   time.Time `db:"date" json:"date"`
	Date_2 time.Time `db:"date_2" json:"date_2"`
}

func (q *Queries) GetDailyUsageByDateRange(ctx context.Context, arg GetDailyUsageByDateRangeParams) ([]DailyUsage, error) {
	rows, err := q.query(ctx, q.getDailyUsageByDateRangeStmt, getDailyUsageByDateRange, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DailyUsage
	for rows.Next() {
		var i DailyUsage
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.TotalTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentDailyUsage = `-- name: GetRecentDailyUsage :many
SELECT id, date, total_time, created_at, updated_at FROM daily_usage
WHERE date >= date('now', '-' || ?1 || ' days')
ORDER BY date DESC
`

func (q *Queries) GetRecentDailyUsage(ctx context.Context, days sql.NullString) ([]DailyUsage, error) {
	rows, err := q.query(ctx, q.getRecentDailyUsageStmt, getRecentDailyUsage, days)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DailyUsage
	for rows.Next() {
		var i DailyUsage
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.TotalTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDailyUsage = `-- name: UpdateDailyUsage :one
UPDATE daily_usage
SET total_time = ?, updated_at = CURRENT_TIMESTAMP
WHERE date = ?
RETURNING id, date, total_time, created_at, updated_at
`

type UpdateDailyUsageParams struct {
	TotalTime int64     `db:"total_time" json:"total_time"`
	Date      time.Time `db:"date" json:"date"`
}

func (q *Queries) UpdateDailyUsage(ctx context.Context, arg UpdateDailyUsageParams) (DailyUsage, error) {
	row := q.queryRow(ctx, q.updateDailyUsageStmt, updateDailyUsage, arg.TotalTime, arg.Date)
	var i DailyUsage
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.TotalTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertDailyUsage = `-- name: UpsertDailyUsage :one
INSERT INTO daily_usage (date, total_time)
VALUES (?, ?)
ON CONFLICT(date) DO UPDATE SET
    total_time = excluded.total_time,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, date, total_time, created_at, updated_at
`

type UpsertDailyUsageParams struct {
	Date      time.Time `db:"date" json:"date"`
	TotalTime int64     `db:"total_time" json:"total_time"`
}

func (q *Queries) UpsertDailyUsage(ctx context.Context, arg UpsertDailyUsageParams) (DailyUsage, error) {
	row := q.queryRow(ctx, q.upsertDailyUsageStmt, upsertDailyUsage, arg.Date, arg.TotalTime)
	var i DailyUsage
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.TotalTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
