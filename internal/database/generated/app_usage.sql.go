// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: app_usage.sql

package queries

import (
	"context"
	"database/sql"
	"time"
)

const batchUpdateAppUsage = `-- name: BatchUpdateAppUsage :exec
UPDATE app_usage
SET duration = max(0, duration + ?), updated_at = CURRENT_TIMESTAMP
WHERE name = ? AND date = ?
`

type BatchUpdateAppUsageParams struct {
	Duration int64     `db:"duration" json:"duration"`
	Name     string    `db:"name" json:"name"`
	Date     time.Time `db:"date" json:"date"`
}

func (q *Queries) BatchUpdateAppUsage(ctx context.Context, arg BatchUpdateAppUsageParams) error {
	_, err := q.exec(ctx, q.batchUpdateAppUsageStmt, batchUpdateAppUsage, arg.Duration, arg.Name, arg.Date)
	return err
}

const createAppUsage = `-- name: CreateAppUsage :one

INSERT INTO app_usage (name, duration, icon_path, exe_path, date)
VALUES (?, ?, ?, ?, ?)
RETURNING id, name, duration, icon_path, exe_path, date, created_at, updated_at
`

type CreateAppUsageParams struct {
	Name     string         `db:"name" json:"name"`
	Duration int64          `db:"duration" json:"duration"`
	IconPath sql.NullString `db:"icon_path" json:"icon_path"`
	ExePath  sql.NullString `db:"exe_path" json:"exe_path"`
	Date     time.Time      `db:"date" json:"date"`
}

// App Usage Queries
// These queries handle CRUD operations for individual application usage data
func (q *Queries) CreateAppUsage(ctx context.Context, arg CreateAppUsageParams) (AppUsage, error) {
	row := q.queryRow(ctx, q.createAppUsageStmt, createAppUsage,
		arg.Name,
		arg.Duration,
		arg.IconPath,
		arg.ExePath,
		arg.Date,
	)
	var i AppUsage
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Duration,
		&i.IconPath,
		&i.ExePath,
		&i.Date,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAppUsage = `-- name: DeleteAppUsage :exec
DELETE FROM app_usage
WHERE name = ? AND date = ?
`

type DeleteAppUsageParams struct {
	Name string    `db:"name" json:"name"`
	Date time.Time `db:"date" json:"date"`
}

func (q *Queries) DeleteAppUsage(ctx context.Context, arg DeleteAppUsageParams) error {
	_, err := q.exec(ctx, q.deleteAppUsageStmt, deleteAppUsage, arg.Name, arg.Date)
	return err
}

const deleteAppUsageByID = `-- name: DeleteAppUsageByID :exec
DELETE FROM app_usage
WHERE id = ?
`

func (q *Queries) DeleteAppUsageByID(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteAppUsageByIDStmt, deleteAppUsageByID, id)
	return err
}

const deleteOldAppUsage = `-- name: DeleteOldAppUsage :exec
DELETE FROM app_usage
WHERE date < ?
`

func (q *Queries) DeleteOldAppUsage(ctx context.Context, date time.Time) error {
	_, err := q.exec(ctx, q.deleteOldAppUsageStmt, deleteOldAppUsage, date)
	return err
}

const getAllAppsForDate = `-- name: GetAllAppsForDate :many
SELECT DISTINCT name FROM app_usage
WHERE date = ?
ORDER BY name
`

func (q *Queries) GetAllAppsForDate(ctx context.Context, date time.Time) ([]string, error) {
	rows, err := q.query(ctx, q.getAllAppsForDateStmt, getAllAppsForDate, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppUsageByDate = `-- name: GetAppUsageByDate :many
SELECT id, name, duration, icon_path, exe_path, date, created_at, updated_at FROM app_usage
WHERE date = ?
ORDER BY duration DESC, name ASC
`

func (q *Queries) GetAppUsageByDate(ctx context.Context, date time.Time) ([]AppUsage, error) {
	rows, err := q.query(ctx, q.getAppUsageByDateStmt, getAppUsageByDate, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppUsage
	for rows.Next() {
		var i AppUsage
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Duration,
			&i.IconPath,
			&i.ExePath,
			&i.Date,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppUsageByDateRange = `-- name: GetAppUsageByDateRange :many
SELECT id, name, duration, icon_path, exe_path, date, created_at, updated_at FROM app_usage
WHERE date >= ? AND date <= ?
ORDER BY date DESC, duration DESC
`

type GetAppUsageByDateRangeParams struct {
	Date   time.Time `db:"date" json:"date"`
	Date_2 time.Time `db:"date_2" json:"date_2"`
}

// Historical data retrieval queries
func (q *Queries) GetAppUsageByDateRange(ctx context.Context, arg GetAppUsageByDateRangeParams) ([]AppUsage, error) {
	rows, err := q.query(ctx, q.getAppUsageByDateRangeStmt, getAppUsageByDateRange, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppUsage
	for rows.Next() {
		var i AppUsage
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Duration,
			&i.IconPath,
			&i.ExePath,
			&i.Date,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppUsageByDateRangePaginated = `-- name: GetAppUsageByDateRangePaginated :many
SELECT id, name, duration, icon_path, exe_path, date, created_at, updated_at FROM app_usage
WHERE date >= ? AND date <= ?
ORDER BY date DESC, duration DESC, id DESC
LIMIT ? OFFSET ?
`

type GetAppUsageByDateRangePaginatedParams struct {
	Date   time.Time `db:"date" json:"date"`
	Date_2 time.Time `db:"date_2" json:"date_2"`
	Limit  int64     `db:"limit" json:"limit"`
	Offset int64     `db:"offset" json:"offset"`
}

func (q *Queries) GetAppUsageByDateRangePaginated(ctx context.Context, arg GetAppUsageByDateRangePaginatedParams) ([]AppUsage, error) {
	rows, err := q.query(ctx, q.getAppUsageByDateRangePaginatedStmt, getAppUsageByDateRangePaginated,
		arg.Date,
		arg.Date_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppUsage
	for rows.Next() {
		var i AppUsage
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Duration,
			&i.IconPath,
			&i.ExePath,
			&i.Date,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppUsageByID = `-- name: GetAppUsageByID :one
SELECT id, name, duration, icon_path, exe_path, date, created_at, updated_at FROM app_usage
WHERE id = ?
`

func (q *Queries) GetAppUsageByID(ctx context.Context, id int64) (AppUsage, error) {
	row := q.queryRow(ctx, q.getAppUsageByIDStmt, getAppUsageByID, id)
	var i AppUsage
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Duration,
		&i.IconPath,
		&i.ExePath,
		&i.Date,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAppUsageByNameAndDate = `-- name: GetAppUsageByNameAndDate :one
SELECT id, name, duration, icon_path, exe_path, date, created_at, updated_at FROM app_usage
WHERE name = ? AND date = ?
`

type GetAppUsageByNameAndDateParams struct {
	Name string    `db:"name" json:"name"`
	Date time.Time `db:"date" json:"date"`
}

func (q *Queries) GetAppUsageByNameAndDate(ctx context.Context, arg GetAppUsageByNameAndDateParams) (AppUsage, error) {
	row := q.queryRow(ctx, q.getAppUsageByNameAndDateStmt, getAppUsageByNameAndDate, arg.Name, arg.Date)
	var i AppUsage
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Duration,
		&i.IconPath,
		&i.ExePath,
		&i.Date,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAppUsageByNameAndDateRange = `-- name: GetAppUsageByNameAndDateRange :many
SELECT id, name, duration, icon_path, exe_path, date, created_at, updated_at FROM app_usage
WHERE name = ? AND date >= ? AND date <= ?
ORDER BY date DESC
`

type GetAppUsageByNameAndDateRangeParams struct {
	Name   string    `db:"name" json:"name"`
	Date   time.Time `db:"date" json:"date"`
	Date_2 time.Time `db:"date_2" json:"date_2"`
}

func (q *Queries) GetAppUsageByNameAndDateRange(ctx context.Context, arg GetAppUsageByNameAndDateRangeParams) ([]AppUsage, error) {
	rows, err := q.query(ctx, q.getAppUsageByNameAndDateRangeStmt, getAppUsageByNameAndDateRange, arg.Name, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppUsage
	for rows.Next() {
		var i AppUsage
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Duration,
			&i.IconPath,
			&i.ExePath,
			&i.Date,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppUsageCountByDateRange = `-- name: GetAppUsageCountByDateRange :one
SELECT COUNT(*) FROM app_usage
WHERE date >= ? AND date <= ?
`

type GetAppUsageCountByDateRangeParams struct {
	Date   time.Time `db:"date" json:"date"`
	Date_2 time.Time `db:"date_2" json:"date_2"`
}

func (q *Queries) GetAppUsageCountByDateRange(ctx context.Context, arg GetAppUsageCountByDateRangeParams) (int64, error) {
	row := q.queryRow(ctx, q.getAppUsageCountByDateRangeStmt, getAppUsageCountByDateRange, arg.Date, arg.Date_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAppUsageHistory = `-- name: GetAppUsageHistory :many
SELECT name, date, duration, icon_path, exe_path
FROM app_usage
WHERE name = ?
ORDER BY date DESC
LIMIT ?
`

type GetAppUsageHistoryParams struct {
	Name  string `db:"name" json:"name"`
	Limit int64  `db:"limit" json:"limit"`
}

type GetAppUsageHistoryRow struct {
	Name     string         `db:"name" json:"name"`
	Date     time.Time      `db:"date" json:"date"`
	Duration int64          `db:"duration" json:"duration"`
	IconPath sql.NullString `db:"icon_path" json:"icon_path"`
	ExePath  sql.NullString `db:"exe_path" json:"exe_path"`
}

func (q *Queries) GetAppUsageHistory(ctx context.Context, arg GetAppUsageHistoryParams) ([]GetAppUsageHistoryRow, error) {
	rows, err := q.query(ctx, q.getAppUsageHistoryStmt, getAppUsageHistory, arg.Name, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAppUsageHistoryRow
	for rows.Next() {
		var i GetAppUsageHistoryRow
		if err := rows.Scan(
			&i.Name,
			&i.Date,
			&i.Duration,
			&i.IconPath,
			&i.ExePath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentAppUsage = `-- name: GetRecentAppUsage :many
SELECT id, name, duration, icon_path, exe_path, date, created_at, updated_at FROM app_usage
WHERE date >= date('now', '-' || ?1 || ' days')
ORDER BY date DESC, duration DESC
`

func (q *Queries) GetRecentAppUsage(ctx context.Context, days sql.NullString) ([]AppUsage, error) {
	rows, err := q.query(ctx, q.getRecentAppUsageStmt, getRecentAppUsage, days)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppUsage
	for rows.Next() {
		var i AppUsage
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Duration,
			&i.IconPath,
			&i.ExePath,
			&i.Date,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopAppsByDate = `-- name: GetTopAppsByDate :many
SELECT id, name, duration, icon_path, exe_path, date, created_at, updated_at FROM app_usage
WHERE date = ?
ORDER BY duration DESC
LIMIT ?
`

type GetTopAppsByDateParams struct {
	Date  time.Time `db:"date" json:"date"`
	Limit int64     `db:"limit" json:"limit"`
}

func (q *Queries) GetTopAppsByDate(ctx context.Context, arg GetTopAppsByDateParams) ([]AppUsage, error) {
	rows, err := q.query(ctx, q.getTopAppsByDateStmt, getTopAppsByDate, arg.Date, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppUsage
	for rows.Next() {
		var i AppUsage
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Duration,
			&i.IconPath,
			&i.ExePath,
			&i.Date,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopAppsByDateRange = `-- name: GetTopAppsByDateRange :many
SELECT name, SUM(duration) as total_duration, COUNT(DISTINCT date) as days_used
FROM app_usage
WHERE date >= ? AND date <= ?
GROUP BY name
ORDER BY total_duration DESC
LIMIT ?
`

type GetTopAppsByDateRangeParams struct {
	Date   time.Time `db:"date" json:"date"`
	Date_2 time.Time `db:"date_2" json:"date_2"`
	Limit  int64     `db:"limit" json:"limit"`
}

type GetTopAppsByDateRangeRow struct {
	Name          string          `db:"name" json:"name"`
	TotalDuration sql.NullFloat64 `db:"total_duration" json:"total_duration"`
	DaysUsed      int64           `db:"days_used" json:"days_used"`
}

func (q *Queries) GetTopAppsByDateRange(ctx context.Context, arg GetTopAppsByDateRangeParams) ([]GetTopAppsByDateRangeRow, error) {
	rows, err := q.query(ctx, q.getTopAppsByDateRangeStmt, getTopAppsByDateRange, arg.Date, arg.Date_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopAppsByDateRangeRow
	for rows.Next() {
		var i GetTopAppsByDateRangeRow
		if err := rows.Scan(&i.Name, &i.TotalDuration, &i.DaysUsed); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsageStatsByDateRange = `-- name: GetUsageStatsByDateRange :many
SELECT 
    date,
    COUNT(*) as app_count,
    SUM(duration) as total_duration,
    AVG(duration) as avg_duration,
    MAX(duration) as max_duration
FROM app_usage
WHERE date >= ? AND date <= ?
GROUP BY date
ORDER BY date DESC
`

type GetUsageStatsByDateRangeParams struct {
	Date   time.Time `db:"date" json:"date"`
	Date_2 time.Time `db:"date_2" json:"date_2"`
}

type GetUsageStatsByDateRangeRow struct {
	Date          time.Time       `db:"date" json:"date"`
	AppCount      int64           `db:"app_count" json:"app_count"`
	TotalDuration sql.NullFloat64 `db:"total_duration" json:"total_duration"`
	AvgDuration   sql.NullFloat64 `db:"avg_duration" json:"avg_duration"`
	MaxDuration   interface{}     `db:"max_duration" json:"max_duration"`
}

func (q *Queries) GetUsageStatsByDateRange(ctx context.Context, arg GetUsageStatsByDateRangeParams) ([]GetUsageStatsByDateRangeRow, error) {
	rows, err := q.query(ctx, q.getUsageStatsByDateRangeStmt, getUsageStatsByDateRange, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsageStatsByDateRangeRow
	for rows.Next() {
		var i GetUsageStatsByDateRangeRow
		if err := rows.Scan(
			&i.Date,
			&i.AppCount,
			&i.TotalDuration,
			&i.AvgDuration,
			&i.MaxDuration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAppUsage = `-- name: InsertAppUsage :exec
INSERT INTO app_usage (name, duration, icon_path, exe_path, date)
VALUES (?, ?, ?, ?, ?)
`

type InsertAppUsageParams struct {
	Name     string         `db:"name" json:"name"`
	Duration int64          `db:"duration" json:"duration"`
	IconPath sql.NullString `db:"icon_path" json:"icon_path"`
	ExePath  sql.NullString `db:"exe_path" json:"exe_path"`
	Date     time.Time      `db:"date" json:"date"`
}

// Single row insert operation
func (q *Queries) InsertAppUsage(ctx context.Context, arg InsertAppUsageParams) error {
	_, err := q.exec(ctx, q.insertAppUsageStmt, insertAppUsage,
		arg.Name,
		arg.Duration,
		arg.IconPath,
		arg.ExePath,
		arg.Date,
	)
	return err
}

const updateAppUsage = `-- name: UpdateAppUsage :one
UPDATE app_usage
SET duration = ?, icon_path = ?, exe_path = ?, updated_at = CURRENT_TIMESTAMP
WHERE name = ? AND date = ?
RETURNING id, name, duration, icon_path, exe_path, date, created_at, updated_at
`

type UpdateAppUsageParams struct {
	Duration int64          `db:"duration" json:"duration"`
	IconPath sql.NullString `db:"icon_path" json:"icon_path"`
	ExePath  sql.NullString `db:"exe_path" json:"exe_path"`
	Name     string         `db:"name" json:"name"`
	Date     time.Time      `db:"date" json:"date"`
}

func (q *Queries) UpdateAppUsage(ctx context.Context, arg UpdateAppUsageParams) (AppUsage, error) {
	row := q.queryRow(ctx, q.updateAppUsageStmt, updateAppUsage,
		arg.Duration,
		arg.IconPath,
		arg.ExePath,
		arg.Name,
		arg.Date,
	)
	var i AppUsage
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Duration,
		&i.IconPath,
		&i.ExePath,
		&i.Date,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertAppUsage = `-- name: UpsertAppUsage :one
INSERT INTO app_usage (name, duration, icon_path, exe_path, date)
VALUES (?, ?, ?, ?, ?)
ON CONFLICT(name, date) DO UPDATE SET
    duration = excluded.duration,
    icon_path = excluded.icon_path,
    exe_path = excluded.exe_path,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, name, duration, icon_path, exe_path, date, created_at, updated_at
`

type UpsertAppUsageParams struct {
	Name     string         `db:"name" json:"name"`
	Duration int64          `db:"duration" json:"duration"`
	IconPath sql.NullString `db:"icon_path" json:"icon_path"`
	ExePath  sql.NullString `db:"exe_path" json:"exe_path"`
	Date     time.Time      `db:"date" json:"date"`
}

func (q *Queries) UpsertAppUsage(ctx context.Context, arg UpsertAppUsageParams) (AppUsage, error) {
	row := q.queryRow(ctx, q.upsertAppUsageStmt, upsertAppUsage,
		arg.Name,
		arg.Duration,
		arg.IconPath,
		arg.ExePath,
		arg.Date,
	)
	var i AppUsage
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Duration,
		&i.IconPath,
		&i.ExePath,
		&i.Date,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
